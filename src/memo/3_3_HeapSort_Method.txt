최대우선순위 큐는 다음의 두가지 연산을 지원한다.
insert(), extractMax() : complete-binary-tree 그리고 max-heap을 생각한채로 그려본다. (둘다 메서드가 작동하기위한 전제조건이다.)

- insert() :
1. max-heap에서 노드를 추가하려면? >> 새로운 노드가 추가될 수 있는 위치는 배열의 끝이다.
(complete binary tree 모양을 유지해야하기 때문)

2. max_heap이 깨질수도 있다. (부모는 자식보다 크거나 같아야함)


3. 새로추가된 노드와 부모 둘 사이를 제외한 다른 곳에서는 max_heap이 아닐 수도 있는 문제가 없다.
    => (새로추가된 자식노드와 부모 둘 사이에서만 max_heap이 깨진다.) **

4. 추가된 자식노드가 부모노드보다 크다면, 부모노드와 스왑해주고, 또 다시 그 부모노드와 크기를 비교해서 자식이 크다면 반복,
    자식보다 부모가 크거나, or 문제의 노드가 부모노드가 없는 루트노드가 되었을때 종료한다.


- extractMax() : 최댓값을 반환 후 출력하는 함수 O(log2N)
1. complete-binary-tree와 max-heap인 경우 최댓값은 루트노드가 된다.

2. 루트노드를 빼도 complete-binary-tree가 유지되려면?
    >> 트리의 마지막노드는 빼도 유지가 된다. 즉 트리의 마지막노드를 루트노드 위치에 놓는다.

3. 일반적으로 max_heap 상태는 깨지게 된다.

4. maxHeapify()
4-1. 루트노드부터 자식노드보다 작다면, 루트노드를 자식노드 중 큰 노드와 교환한다.
2-2. 부모노드가 자식노드보다 작다면, 자식노드 비교해서 자식노드 중 큰 쪽과 부모노드를 교환한다.
4-3. 부모노드가 자식노드보다 큰 상태거나, 부모노드가 자식노드가 없는 리프노드에 도달하였다면 종료한다.




