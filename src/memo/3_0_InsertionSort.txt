- 삽입정렬 O(n^2) ~ O(n-1)

- 정렬이 되지 않은 경우
2번째 데이터로 시작한다.
2번째 데이터를 1번째 데이터와 크게를 비교하여, 알맞은 위치에 삽입한다.
3번째 데이터를 (1~2번째) 데이터들과 크게를 비교하여, 알맞은 위치에 삽입한다.
...
마지막 데이터를 (1번쨰 ~ 마지막-1) 데이터들과 크기를 비교하여, (1번쨰 ~ 마지막-1) 데이터의 왼쪽 or 오른쪽으로 삽입한다.
끝.

정확히는 삽입이라기 보다는 치환하여 한칸씩 뒤로 밀어줘야한다.


- 현재 인덱스 앞부분까지 부분적으로 정렬이 된 경우.
    * 0번 인덱스 친구부터 비교하면서 나보다 같거나 작은 녀석이 있다면 그녀석의 인덱스+1위치에 삽입한다.

    * 내 앞의 인덱스 친구부터 비교(compare)하면서 이 친구가 나보다 크다면 한칸씩 오른쪽(shift)으로 밀어준다. (내 값은 temp에 넣어두면 되지.)
    그리고 내 앞의 인덱스 친구가 나와 같거나 작다면 동작정지. << 이게 더 편할듯? **


for문 배열 2번쨰부터 끝까지 반복. (n-1번 반복)
[1~i]의 적당한 자리에 삽입한다. (삽입은 최악의 경우 i-1번반복)

** 최악의 경우일 때만 O(n^2)이고, 최선의 경우 정렬이 되어있다는 가정하 O(n-1),
** 평균적으로는 선택정렬이나 버블정렬보다 절반정도의 시간복잡도를 갖는다.
