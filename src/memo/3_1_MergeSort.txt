- 합병정렬 O(NlogN)
N = 8일때
N번비교 후 합침 (2 2 2 2) > N번비교 후 합침 (4 4)> N번비교 후 합침 (8)
N번비교 * logN번 합침
이진탐색과 비슷하지만 정렬해야해서 N번비교까지 해야함 32:48


해결하고자 하는 문제를 작은 크기의 동일한 문제들로 '분할'
각각의 작은 문제들을 순환적으로 '정복'
작은 문제의 해를 '합병'하여 원래 문제의 해를 구함

문제의 크기를 쪼갠 후 recursion으로 해결 >> 합병하여 해를 구함.



ex) [2, 8, 6, 4, 5, 9, 7, 3]를 합병정렬하려면? (추가배열을 이용해)

2vs8, 6vs4, 5vs9, 7vs3 -> 28 46 59 37

28 vs 46 -> 2vs4=2, 8vs4=4, 8vs6=6, 8 -> 2468
59 vs 37 -> 5vs3=3, 5vs7=5, 9vs7=7, 9 -> 3579

2468 vs 3579
2vs3=2, 4vs3=3, 4vs5=4, ... , 8vs7=7, 8vs9=8, 9
23456789로 정렬


배열A의 begin부터 end까지 정렬하는 알고리즘
    mergeSort()
    begin < end 일때 정렬알고리즘 사용
        middle = (begin + end) / 2
        재귀전반부(begin ~ middle)!
        재귀후반부(middle+1 ~ end)
        merge(begin~end) # 따로구현한 메서드
        ** merge함수 : (정렬되어있는)전반부배열과 후반부배열을 합하여 정렬된 하나의 배열 A[p~r]을 만든다.

// **** recursion이 처음~중간, 중간~끝 2가지 2번실행되니까, 처음에는 함수가 2번 다음에는 4번 종료조건까지 무한반복.
