-HashTable
    dynamic set을 구현하는 효과적인 방법 중 하나이다.
    적절한 가정 하 search, insert, delete 연산의 시간은 O(1)이다. , 최악의 경우 세타(n)
        레드블랙트리의 경우 3가지 연산인 모두 O(NlogN)이었다.

    ** 배열 T, 특정 값 x, 해시함수 h()일때 T[h(x)] = x이다.  (h()는 u를 0 ~ m-1로 변환시키는 함수)
        ex) h(k) = k % m, 항상 0~m-1의 정수 반환
        데이터를 저장할 때 걸리는 시간이 해시함수를 계산하는데 걸리는 시간과 동일하게 된다. (가정 하 O(1))

    모든 키를 자연수로 가정. (어떤 데이터든 자연수로 변환가능, ASCII코드)

- collision : 해시함수는 단사함수(일대일함수)가 아니다.
    만약 2개의 키가 동일한 위치로 해싱되는 경우  (h(k1) = h(k2)인 상황)
    일반적으로 |u| >> m 이므로 항상 발생가능 (u = universe of keys , m = index)

    충돌이 발생할 경우 chaining, open address 사용.

- chaining : 만약 2개의 키가 동일한 위치로 해싱되는 경우
    동일한 위치에 있는 키들을 연결리스트로 만든다.

    - insertion :
        새로운 키를 연결리스트의 '맨 앞'에 삽입 O(1) (연결리스트의 특징으로 리스트의 마지막 값을 찾으려면 처음부터 순차탐색해야함)
        중복저장이 안되는 경우, 새로운 값을 저장할 때마다 이미 연결리스트에 있는지 검사를 해야한다., 시간복잡도는 연결리스트의 길이에 비례

    - search :
        리스트 T[H(k)]에서 연결리스트 안 순차탐색, 시간복잡도는 연결리스트의 길이에 비례

    - delete :
        search로 값을 찾고 + 찾은 값을 삭제 O(1)

    - 최악일 때, 저장한 모든 키가 같은 해시값을 갖는 경우, 길이가 n인 연결리스트가 만들어짐 >> O(n) + 해시함수계산시간
        ex) (무한개의 수/인덱스의 수) >> 무한대/상수 >> 무한대 >> 길이가 n인 연결리스트.. 가능함

    - 때문에 평균시간복잡도를 이야기함. N개의 키가 여러 슬롯에 골고루 분산될수록, 각각의 연결리스트의 길이는 짧아짐


- SUHA (Simple Uniform Hashing Assumption)
    각각의 키가 모두 균등한 확률로 독립적으로 해싱된다는 가정. (성능분석을 위주로 하는 가정이다.)

    hash함수가 키 값을 각각의 인덱스로 동일한 확률로 보내는 것이 아니라 키 값 자체가 이미 갈 위치가 정해져 있는 것이기 때문에 (deterministic)
    현실에서는 불가능한 가정일 뿐이다.

    하지만 랜덤하게 선택하는 U가 hash함수를 거쳐 각각의 인덱스로 갈 확률이 동일하다는 가정은 할 수 있다.

    - 하나의 연결리스트에 저장된 키의 개수 = (입력된 전체 키의 개수(n)/인덱스 개수(m))
        만약 n = O(m) >> O (n/m) = O(1)
        길이가 8인 배열에 8개의 데이터가 입력되었고, 각각의 인덱스에 1개씩 데이터가 저장되었다면 O(1)이지 ;
        SUHA가정 아래 이런 특이한 경우에만 평균검색시간이 O(1)이다.


- Open Addressing에 의한 충돌해결
    모든 키를 해쉬테이블 자체에 저장, 테이블의 각 칸에는 1개의 키만 저장. (충돌이 생기면 해싱된 슬롯이 아닌 다른 슬롯에 저장한다는 말이기도 하다.)

    - Linear probing(순차적으로 조사하는?)
        키가 중복된 값이라면 h(k)+1, h(k)+2.. 순차적으로 검사하여 빈 슬롯에 저장.
        테이블 끝에 도달하게되면 다시 처음으로 circular하게 돌아간다.

        Search의 경우 h(k)에 저장된 데이터가 없다면 원하는 값을 찾을 때까지 h(k)+1 h(k)+2... 연속해서 쭉 검색한다.
        빈슬롯에 도달할 때까지만 검색한다.(빈슬롯에 우선적으로 저장하기 때문에 빈슬롯이 검색되었다면 여기서부터는 데이터가 없다.)

        - 단점 : Primary Cluster(키에 의해서 채워진 연속된 슬롯)이 생성된다면 이 cluster는 점점 더 커지는 경향이 생김.
                >> 중복된 값이 계속 추가된다면 Chaining의 최악의 경우와 다를 바 없음.

    - Quadratic probing : 충돌발생 시 h(k) h(k)+1^2, h(k)+2^2 ... 순으로 시도. (circular)
        >> 충돌발생 시 일정한 규칙으로 다음 슬롯을 찾고 빈 슬롯이라면 저장. // cluster를 완화하기 위함

    - Double hashing : 서로 다른 해시함수 h1, h2를 이용
        h(k,i) = h1(k) + (i * h2(k)) // 2번쨰 추가부터 h2(k) * i가 추가된다.
        Quadratic probing과 근본적으로는 같다. // cluster를 완화하기 위함

        ** Quadratic probing과 Double hashing의 차이점.
            Quadratic probing은 고정된 값을 추가하여 빈 슬롯을 찾는다.
            하지만 Double hashing은  k의 값이 따라 h2로 추가되는 값이 크기가 달라진다.


    - Linear probing의 Delete ***
        동일한 해시값을 같은 데이터 a,b,c가 연속적으로 저장되어있는데 b를 삭제한다면?
            >> a의 다음 슬롯이 빈 슬롯이라 c의 검색불가. (빈슬롯에 도달할 때까지만 검색하기 때문)

        단순히 데이터를 삭제하면 위와 같은 문제가 발생한다. 빈슬롯을 어떻게 해야할까?
            >> 삭제된 데이터와 같은 해시값인 데이터 중 가장 나중에 저장된 데이터를 옮겨줘야하는건가?


- 좋은 해시함수란?
    키가 해시테이블에 얼마나 골고루 분포되는가 >> 어떤 해시함수를 사용하느냐가 성능에 영향을 끼친다.

    해시테이블의 각 슬롯마다 U가 포함될 수 있는 부분집합의 크기가 전부 동일하다면, (슬롯마다 조건의범위가 동일하다면)
    Universe of keys에서 랜덤하게 어떤 수를 뽑았을 때, 각각의 슬롯에 독립적으로 해싱될 확률은 1/m로 동일하다.

    현실의 데이터는 일정한 패턴과 공통점을 가지고 있다. ex) 학번은 N자리 자연수, 이름의 이니셜로 z,q가 올 확률은 낮다.
    하지만 해시함수는 정렬된 데이터와는 다르게 '불규칙적인 규칙'이 있어야 바람직하다. (해시테이블에 골고루 분포시키기 위함)
        >> 규칙성이 없는 패턴을 규칙으로 만들어서 해시함수의 패턴으로 사용하자.

    - Division 기법
        h(k) = k % m (0 ~ m-1로 변환하는 가장 쉬운 방법으로 보통 복잡한 기법 뒤에 마지막에 나옴.)
        >> Division 기법만 사용한다면, 해시함수의 값이 키의 일부분에 의해서만 결정된다. (규칙적인 패턴이다.)

    - Multiplication 기법 : 키들의 공통적인 패턴을 무시하는 불규칙적인 규칙에 가깝다.
        0<A<1 (A는 소수)
        A * K 의 소수부분만 선택한다.
        소수부분에 m을 곱하고 소수점 아래를 버린다.

        m=8 , k=21, A= 0.32 를 선택
        AK = 0.32 * 21 = 6 + (72/100)
        0.72 * 8 = 5 + 0.76 >> 5
        h(21) = 5
        >> 랜덤소수에 k를 곱한 값의 소수점에 m을 곱한 정수값




- Hashing in Java
    Object 클래스는 hashCode()를 가지고 있다.
        >> 따라서 '모든 클래스'는 hashCode()를 상속받는다. (클래스들의 대장이 Object클래스이므로)
        >> 이 메서드는 32비트 정수를 반환한다.(양수음수)

    만약 x.equals(y)이면 x.hashCode()==y.hashCode()이다. (역은 성립하지 않는다.)
        >> 똑같은 값을 가진 키라면 해시함수 값도 똑같다. but 해시함수 값이 같다고 똑같은 값을 가진 키는 아니다.
            >> 왜? 1024든 2024든 해시함수 값이 24일수도 있음 (해시함수가 k % m 일때), 또한 역이 성립한다면 collision이 일어날 일이 없음.

    필요에 따라 각 클래스(type)마다 이 메서드를 override하여 사용한다.


- HashCode와 Hash함수
    HashCode는 32비트 정수, Hash함수는 HashCode를 (0 ~ m-1)의 배열 인덱스로의 변환

    private int hash(Key key) { // 편한 검색과 수정용
        return (key.hashCode() & 0x7fffffff) % m;
    }
        // 0x7fffffff에서 0은 32비트 정수에서 양수를 뜻함
        // % m의 경우 나머지가 (0 ~ m-1)

- 자바에서 해시 사용
    내부적으로 하나의 배열을 해시테이블로 사용
    chaining으로 충돌해결
    0~1사이의 실수인 load factor(부하율) 지정가능
    load factor를 초과하면 더 큰 배열을 할당하고 저장된 키를 재배치(re-hashing)
        >> ex) 배열의 크기 * 0.8 < 키의 개수 , 배열의 길이가 달라지므로 리해싱까지

- HashSet : 하나의 집합이다.
    새로운 원소 추가 삭제 : add() remove()
    특정한 원소를 포함하고 있는지 검사 : contains()
    반복문기능 iterator()도 제공






