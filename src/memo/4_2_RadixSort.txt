O(d(n+k)
// d가 상수, k < n일때, O(n) 리니어다.
n개의 d자리 정수들 (사전조건), 가장 낮은 자릿수부터 정렬, k는 k진수 알파벳k개.

stable algorithm : 입력에 동일한 값이 있을때 입력에 먼저 나오는 값이 출력에서도 먼저 나온다.
    ex) 320 420을 십의 자리 수 정렬을 한다면? >> 각각의 정수가 포함하고 있는 2가 서로 바뀌면 안된다.
        왜? 레코드라면 가르키는 데이터가 바뀌기 때문에.

- 일의 자리 정렬 후 십의 자리 정렬 = 십의자리까지 정렬이 되어있다. // 더 큰 수라면 정렬되어있으니까 굳이 건들지않아도 된다.
    >> 마지막 자릿수부터 첫번째 자릿수까지 정렬 = stable algorithm 정렬완료.

11분 : 2번째자릿수가 동일하다면? 마지막자릿수의 크기정렬은 이미 끝났기 때문에 마지막자릿수가 큰 놈은 그대로 밑으로 작은 놈은 위로
위치변화없이 stable algorithm 유지.

(** 현재 2번째정렬 크기가 동일하다면? 3번째정렬순으로 판별 >> 3번쨰자리 크기도 동일하다면? >> 4번째자리 크기정렬 순으로 판별
stable하게 있다. **)

