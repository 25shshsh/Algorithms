- Kruscal의 알고리즘
    1. 에지들을 오름차순으로 정렬한다.
    2. 에지들을 순서대로 선택한다. 단, 이미 선택한 에지들과 사이클을 형성하면 안 된다.
    3. 에지가 n-1개가 된다면 종료한다.
        >> 사이클을 형성하였는지 어떻게 판별할까?
           연결되어있는 노드들을 각각의 부분집합으로 만든다. 그럼 부분집합내에서 연결된다면 사이클이 도는 것으로 확인가능하다.
           서로다른 집합에 속해있다 서로 연결하더라도 사이클이 생기지 않는다.
    - 어째서 MST가 만들어질까? (15-2 5분)
        ex) (공집합부터 안전하게 만들어진) 부분집합들을 가장 낮은 가중치를 cross한다. >> 안전한 부분집합2개에서 안전한 부분집합1개로 병합과 같다.

    - 어떤 에지도 연결되지 않은 초기상태일 때 >> 노드의 개수가 n개라면 집합의 개수도 n개이다.

    - 사이클 검사 : 가중치가 최소인 에지를 고려한다. 만약같은 집합내에 있으면 다음 가중치의 에지를 고려한다.
        다른 집합에 속해있다면 연결한다. = 각각의 부분집합들을 합쳐서 하나의 부분집합으로 만든다.

- 서로소인 집합들(공통원소가 없는 집합)을 어떤 자료구조로 표현?
    각각의 집합을 하나의 상향식트리로 표현한다. 트리내부는 어떻든 상관없다.
    상향식트리 : 자식노드가 부모노드의 정보를 가지고있으면 된다. (루트는 자기주소)

    - 부분집합이 몇개든 각각의 원소의 부모노드를 가르키는 주소를 하나의 배열로 만들수있다.. ****
        ex) p[child] = parent

    - findSet(x) : 두 노드가 동일한 집합인가?
        자기자신을 부모로 가르키는 노드(루트노드)가 서로 동일한가? = 동일한 집합인가?
        if x != p[x] >> findSet(p[x]) // recursion으로 루트까지 타고올라가면된다.

    - union(u,v)
        각 부분집합의 루트노드 중 하나가 다른 한쪽의 루트노드의 자식으로 들어가면 된다.
        ex) p[u] = u에서 p[u] = v

15-3강 20분
