- 빠른정렬
최악의 경우 세타(N^2) : 정렬이 되어있고 피벗이 최댓값이거나 최솟값이라면, 분할이 안되니까 하나하나 정렬하는 것과 차이가 없다.
정렬이 끝날때마다 원소는 N N-1 N-2 .... 2 1 >> n(n-1)/2 의 시간복잡도.

- 로직순서 **
    기준원소를 잡고 기준원소보다 큰지 작은지에 따라 양쪽으로 나눈다.
    기준원소를 기준으로 나눠진 양쪽배열을 또 기준원소를 잡고 크기에 따라 양쪽으로 나눈다.
    위 작업을 (시작원소 < 기준원소-1)동안 반복한다. 끝.

최선의 경우 NlogN: 연속적으로 항상 절반으로 분할 될 경우 >> MergeSort와 동일하다.
평균복잡도도 nlogn

하지만 항상 9:1이상이 되도록 분할된다면?
(9/10)^k * n = 1 이 되려면 k = log (10/9) N 이다.
log (10/9) N 는 세타 log2 (상수)가 된다.
k = 세타 log2 n 이 된다.
분할 마다 log2N, MergeSort와 같다.

>> 분할이 아주 극단적으로 10:0이지 않은 이상 빠르다.

- 평균시간복잡도에서 길이가 5인 배열이 정렬된 상태로 들어오려면 모든 순열 중 하나 즉 (1/5!)의 확률이다.



quickSort(A[], p, r) {

    if(p < r) {
        q = partition(A, p, r);
        quickSort(A, p, q-1);
        quickSort(A, q+1, r);
    }
}

partition(A[], p, r) {
    배열 A[p....r]의 원소들을 A[r]의 크기를 기준으로 양쪽으로 재배치하고
    A[r]이 자리한 위치를 return한다;
}


randomized quicksort : **** 최악의 경우를 피하기 위해 피벗을 랜덤선택한 후. arr[arr.length-1]과 스왑하고 퀵소트 시작 ****

- partition() : A[r]은 피벗, i는 피벗보다 작은 수 중 가장 마지막 인덱스, j는 다음 정렬 대상,

i = 0, j = 4, pivot = 15

ex) [8], [31, 48, 73], 11, 9, 15
    i                   j

- a[j] < pivot 일때
ex) [8, 11], [48, 73, 31], 9, 15
         i                 j

먼저 i = i+1
A[i]와 A[j]를 치환
j = j+1




